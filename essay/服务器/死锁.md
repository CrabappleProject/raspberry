死锁,银行家算法

## 死锁

### 什么是死锁?
死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
### 产生死锁的必要条件

只要任何一个条件都不成立,则不会发生死锁,只有下面的条件全部同时成立时才会发生死锁.

1.互斥条件: 某资源在某一时间段内只能被一个进程占用.
2.请求和保持条件: 进程已经持有一至少一个资源,但是有请求一个新资源,而新资源又被另一个进程占用,此时请求即被阻塞,但对自己活得的资源又不释放.
3.不可抢占条件: 进程已获得的资源在未使用完前**不能被抢占**,只能在进程使用完后自由释放.
4.循环等待条件: 发生死锁时,资源占用必然有个循环等待链.

### 处理死锁的方法
1.预防死锁: 破坏四个必要条件之一或之几.
2.避免死锁: 分配资源时,防止系统进入不安全状态.
3.检测死锁: 程序运行过程中,检测机构能检测出来,并将进程从死锁中解脱出来.
4.解除死锁: 解救进程,常见方法有撤销进程.

### 银行家算法 --- 避免死锁
1.**核心:**当新进程请求一组资源时,系统必须首先确定是否有足够的资源分配给该进程,若有,再进一步计算这些资源分配给进程后,是否会使系统处于不安全状态.
2.**数据结构:** 

- Available:系统 每个资源空闲量.
- Max: 各进程对资源的原始需求量.
- Allocation: 已分配给各个线程的资源量.
- Need: 各个线程还需要多少资源量.
所以: Max=Allocation+Need.

判断是否安全,则能不能找到安全序列.

| 进程\\资源情况 | Max     | Allocation | Need    | Available |
| -------------- | ------- | ---------- | ------- | --------- |
| p0             | 1  1  1 | 1  1  0    | 0  0  1 | 2  2  2   |
| p1             | 2  1  1 | 1  1  0    | 1  0  1 |           |
| p2             | 1  1  2 | 0  0  0    | 1  1  2 |           |

| 进程\\资源情况 | Work    | Need    | Allocation | Work+Allocation | Finish |
| -------------- | ------- | ------- | ---------- | --------------- | ------ |
| p0             | 2  2  2 | 0  0  1 | 1  1  0    | 3  3  2         | true   |
| p1             | 3  3  2 | 1  0  1 | 1  1  0    | 4  4  2         | true   |
| p2             | 4  4  2 | 1  1  2 | 0  0  0    | 4  4  2         | true   |

所以安全序列为 p0->p1->p2,能找到安全序列,所以该系统安全.

